head	1.1;
access;
symbols;
locks
	mjd:1.1; strict;
comment	@# @;


1.1
date	2001.10.18.00.52.43;	author mjd;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@package Mod::Generic;


sub new {
  my $pack = shift;
  my $self = { paragraph => \%{$pack . '::paragraph'},
               command => \%{$pack . '::command'},
               escape => \%{$pack . '::escape'},
               line => 1,
               char => 0,
             };
  bless $self => $pack;
  $self;
}

sub extension { "out" }

sub init { }

sub filenamecvt {
  my ($self, $out) = @@_;
  my $ext = "." . $self->extension();
  $out =~ s/.mod$/$ext/ or $out .= $ext;
  $out;
}

sub do_file {
  my ($self, $in, $out) = @@_;
  local(*IN, *OUT);
  unless (open IN, "< $in") {
    warn "Couldn't open < $in: $!; skipping.\n";
    next;
  }
  unless (defined $out) {
    $out = $self->filenamecvt($in);
  }
  unless (open OUT, "> $out") {
    warn "Couldn't open > $out: $!; skipping.\n";
    return;
  }


  my $result;
  { local $/;
    my $contents = <IN>;
    $result = $self->do_text($contents);
    close IN;
  }
  print OUT $result;
  close OUT;
}

sub _type_token {
  return ['whitespace', undef, $_] unless /\S/;
  if (/^\=(\w+)\s*/) {
    my $command = $1;
    $command =~ tr/A-Z=/a-z/d;
    my $argtext = $_;
    $argtext =~ s/^\=(\w+)\s*//;
    my @@args = ($command, split /\s+/, $argtext);
    return ['command', \@@args, $_];
  } elsif (/^([ \t*].*\n?)+$/) { # Indented paragraph
    my $stars = /^\*/m ? ['stars'] : undef;
    return ['program', $stars, $_];
  } else {
    return ['prose', undef, $_];
  }
}

sub do_text {
  my ($self, $text) = @@_;
  $self->init() unless $self->{Inited}++;
  my $toks = $self->tokenize($text);
  $self->do_tokens($toks);
}

sub tokenize {
  my ($self, $text) = @@_;

  my @@tokens = split /(^\s*|\n\s*\n)/, $text;
  @@tokens = map _type_token($_), @@tokens;
  my @@t2;

  # Combine consecutive program token into single program token
  for (my $i=0; $i < @@tokens; $i++) {
    my $t = $tokens[$i];
    last unless defined $t;
    unless ($t->[0] eq 'program') {
      push @@t2, $t;
      next;
    }

    # look ahead.  If there's more program text next
    # (possibly with intervening whitespace) then it (and any intervening space)
    # gets coalesced with this token.
    my $last_program_j;
    for (my $j = $i+1;
         $j < @@tokens &&
         ($tokens[$j][0] eq 'program' || $tokens[$j][0] eq 'whitespace');
         $j++) {
      $last_program_j = $j if $tokens[$j][0] eq 'program';  #  XXX repeated code
    }

    for my $j ($i+1 .. $last_program_j) {
      $t->[1] ||= $tokens[$j][1];
      $t->[2] .=  $tokens[$j][2];
    }
    push @@t2, $t;
    $i = $last_program_j if defined $last_program_j;
  }
  wantarray ? @@t2 : \@@t2;
}

sub do_tokens {
  my ($self, $tokens) = @@_;
  my $result = '';

  for (@@$tokens) {
    my ($toktype, $args, $text) = @@$_;

    my $lines = $text =~ tr/\n//;
    my $chars = length $text;

    my ($output, %option) = $self->format_paragraph($toktype, $args, $text);
    $result .= $output if defined $output;

    $self->{line} += $lines;
    $self->{char} += $chars;
    $self->{last_tok} = $_;

    last if $option{Stop};
  }
  return $result;
}

sub warning {
  my ($self, $msg) = @@_;
  if (lc $msg eq 'diag') { 
    return; # or $msg = shift;
  }
  print STDERR "*** ", $msg, " near line $self->{line} (char $self->{char}) of input.\n";
}

sub setparam {
  my ($self, $key, $value) = @@_;
  $self->{param}{$key} = $value;
}

sub getparam {
  my ($self, $key, $default) = @@_;
  if (exists $self->{param}{$key}) {
    $self->{param}{$key};
  } else {
    $default;
  }
}

sub scrub_escapes {
  my ($self, $t) = @@_;
  $self->expand_escapes($t, Scrub => 1);
}

# Seems to work OK.
sub expand_escapes {
  my ($self, $t, %OPT) = @@_;
  $o = $OPT{Open} || '<';
  $c = $OPT{Close} || '>';

  my $tok_regex = qr/([A-Z]\Q$o\E)|((?<!\\)(?:\\\\)*\Q$c\E)/;
  my @@toks = split $tok_regex, $t;
  my $transformed = '';
  my ($code_type, $contents) = ('', '');
  my $depth = 0;


  while (@@toks) {
    my ($plaintext, $start, $end) = splice @@toks, 0, 3;
    if ($start && $end) {
      die "GACK!  start and end both matched!\n";
    }
    if ($plaintext ne '') {
      if ($depth == 0) {
        $transformed .= $plaintext;
      } else {
        $contents .= $plaintext;
      }
    }

#    $self->{line} += ($plaintext =~ tr/\n//);
#    $self->{char} += length $plaintext;

    if ($start ne '') {
      $contents .= $start;
      if ($depth++ == 0) {
        ($code_type) = ($start =~ /([A-Z])/);
      }
#      $self->{line} += ($start =~ tr/\n//);
#      $self->{char} += length $start;
    } elsif ($end) {
      $contents .= $end;
      my ($cont2) = ($contents =~ /^..(.*).$/s);
      if (--$depth == 0) {
        if ($OPT{Scrub}) {
          $transformed .= $cont2;
        } else {
          $transformed .= $self->format_escape($code_type, $cont2);
        }
        $code_type = $contents = '';
      }
      if ($depth < 0) {
        $self->warning("Unmatched $c");
      }
#      $self->{line} += ($end =~ tr/\n//);
#      $self->{char} += length $end;
    }
  }
  $transformed;
}


# default method uses dispatch tables defined in the subclass
sub format_paragraph {
  my ($self, $ptype, $args, $text) = @@_;

  if ($ptype eq 'command') { 
    my ($command, @@args) = @@$args;
    my $code =
         $self->{command}{$command}  # specific handler for this command
      || $self->{paragraph}{$ptype}; # catchall command handler
    return $text unless defined $code;
    $text =~ s/^=\w+\s+//;
    return $code->($self, $command, $text, @@args);
  } else {
    my $code = $self->{paragraph}{$ptype};
    return $text unless defined $code;
    return $code->($self, $text, @@args);
  }
}

# default method uses dispatch tables defined in the subclass
sub format_escape {
  my ($self, $char, $text) = @@_;
  my $code = $self->{escape}{$char};
  return $text unless defined $code;
  $code->($self, $char, $text);
}

1;


@
