head	1.1;
access;
symbols;
locks
	mjd:1.1; strict;
comment	@# @;


1.1
date	2001.10.16.15.11.07;	author mjd;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!/usr/bin/perl -w

package Mod::Driver;

sub import {
  my $pack = shift;
}

sub new {
  my $pack = shift;
  my $driver = shift;
  my $drivermod = "Mod::\u\L$driver";
  my $driverfile = "Mod/\u\L$driver.pm";
  unless ($INC{$driverfile}) {
    *{$drivermod . '::warning'} = \&warning;
    require $driverfile;
    $drivermod->import(@@_);
  }
  my $self = { process => \%{$drivermod . '::process'},
               transform => \%{$drivermod . '::transform'},
               result => $driver,
             };
  bless $self => $pack;
}

sub filenamecvt {
  my ($self, $out) = @@_;
  $out =~ s/.mod$/.txt/ or $out .= '.txt'; # FIX
  $out;
}

sub dofile {
  my ($self, $in, $out) = @@_;
  local *FH;
  unless (open FH, "< $in") {
    warn "Couldn't open < $in: $!; skipping.\n";
    next;
  }
  my $contents;
  { local $/;
    $contents = <FH>;
  }


  unless (defined $out) {
    $out = $self->filenamecvt($in);
  }
  unless (open FH, "> $out") {
    warn "Couldn't open > $out: $!; skipping.\n";
    return;
  }
  
  local *process = $self->{process};
  local *transform = $self->{transform};

  if ($process{init}) {
    $process{init}->($self);
  }

  my @@tokens = split /(\n\s*\n)/, $contents;
  my $last_tok = '';
 TOKEN:
  while (@@tokens) {
    my ($toktype);
    my @@args;
    local $_ = shift @@tokens;
    if (! /\S/) {               # All whitespace
      $toktype = 'whitespace';
    } elsif (s/^\=(\w+)\s*//) {
      $toktype = $1;
      $toktype =~ tr/A-Z=/a-z/d;
      @@args = split;
#      print ">> =$toktype directive.\n";
    } elsif (/^([ \t*].*\n?)+$/) { # Indented paragraph
      $toktype = 'program';
    } else {
      $toktype = 'paragraph';
    }

    my $code;
  RESOLVE_CODE:
    {
      $code = $process{$toktype} || $process{DEFAULT};
#      redo RESOLVE_CODE unless defined ref $code;
      unless (defined $code) {
        warn "Unrecognized code type `$toktype'; using null\n";
        $code = sub { return $_[1] };
      }
    }

    $LINE += tr/\n//;
    $CHAR += length;

    my ($output, %option) = $code->($toktype, $_, $last_tok, @@args,);
    $last_tok = $toktype;

    if ($option{Stop}) {
      last TOKEN;
    }

    print FH $output if defined $output;
  }
}


sub warning {
  my ($msg) = @@_;
  if (lc $msg eq 'diag') { 
    return; # or $msg = shift;
  }
  print STDERR "*** ", $msg, " near line $LINE (char $CHAR) of input.\n";
}

sub setparam {
  my ($self, $key, $value) = @@_;
  $self->{param}{$key} = $value;
}

sub getparam {
  my ($self, $key, $default) = @@_;
  if (exists $self->{param}{$key}) {
    $self->{param}{$key};
  } else {
    $default;
  }
}

sub transform {
  my ($text) = @@_;
  $text = mod_escape($text, \&dispatch_transformation);
  return $text;
}

sub mod_escape {
  my ($t, $code, $o, $c) = @@_;
  $o = '<' unless defined $o;
  $c = '>' unless defined $c;

  while ('true') {
#    print "--$t--\n";
    my ($cp, $op);
    my $curs = 0;
    my $backslashes;
    do {
      $backslashes = 0;
      $cp = index  $t, $c, $curs;
      last if $cp < 0;
      $curs = $cp+1;
      # Odd number of backslashes means the > is escaped
      ++$backslashes while substr($t, $cp-1-$backslashes, 1) eq '\\';
    } while ($backslashes % 2 == 1);
    # $cp is now the index of the first unescaped )
    last if $cp < 0;

    $curs = $cp - 1;
    do {
      $op = rindex  $t, $o, $curs;
      $curs = $op-1;
    } while ($op >= 1 && substr($t, $op-1, 1) !~ /[A-Z]/);
    # $cp is now the index of the first preceding ( that has a tag
    last if $op < 1;

    my $tagged_section = substr($t, $op-1, $cp-$op+2);
    $tagged_section =~ s/\\</</g;
    $tagged_section =~ s/\\>/>/g;
    substr($t, $op-1, $cp-$op+2) = $code->($tagged_section);
  }

  return $t;
}

1;
@
