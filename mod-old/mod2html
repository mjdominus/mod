#!/usr/bin/perl -w

die "Usage: $0 file...\n" unless @ARGV;

require 'mod-text.pl';

for my $file (@ARGV) {
  local *FH;
  unless (open FH, "< $file") {
    warn "Couldn't open < $file: $!; skipping.\n";
    next;
  }
  
  my $contents;
  { local $/;
    $contents = <FH>;
  }

  $file =~ s/.mod$/.html/ or $file .= '.html';
  unless (open FH, "> $file") {
    warn "Couldn't open > $file: $!; skipping.\n";
    next;
  }

  if ($process{init}) {
    $process{init}->();
  }

  my @tokens = split /(\n\s+\n)/, $contents;
 TOKEN:
  while (@tokens) {
    my ($toktype, $last_tok);
    my @args;
    local $_ = shift @tokens;
    if (! /\S/) {               # All whitespace
      $toktype = 'whitespace';
    } elsif (/^\=(\w+)\s/) {
      ($toktype, @args) = split;
      $toktype =~ tr/A-Z=/a-z/d
    } elsif (/\A([\s*]+).*\n($1.*\n)*\z/) { # Indented paragraph
      $toktype = 'indented';
      @args = $1;
    } else {
      $toktype = 'paragraph';
    }

  RESOLVE_CODE:
    {
      my $code = $process{$toktype} || $process{DEFAULT};
      redo RESOLVE_CODE unless defined ref $code;
      unless (defined $code) {
        warn "Unrecognized code type `$toktype'; using null\n";
        $code = sub { return $_[1] };
        last RESOLVE_CODE;
      }
    }
      

    my ($output, %option) = $code->($toktype, $_, $last_tok, @args,);
    if ($option{Stop}) {
      last TOKEN;
    }

    print $output;
  }
}


